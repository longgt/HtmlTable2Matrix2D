{
  "version": 3,
  "sources": ["../mtable.js"],
  "sourcesContent": ["/**\n * @license MIT License\n *\n * Copyright (c) 2023 longgt\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n **/\n'use strict';\n(function() {\n    let my = {};\n    my.mtTable = (function() {\n        let mt;\n        let debug;\n\n        /**\n         * Transform relative position to absolute\n         */\n        function r2aPosition(row, col, mt) {\n            let result = col;\n            let cnt = -1;\n            let colCnt = mt[0].length;\n\n            for (let i = 0; i < colCnt; i++) {\n                if (mt[row][i] > 0) {\n                    cnt++;\n                }\n                if (cnt == col) {\n                    result = i;\n                    break;\n                }\n            }\n            return result;\n        }\n\n        /**\n         * Transform absolute position to relative\n         */\n        function a2rPosition(row, col, mt) {\n            let cnt = 0;\n\n            for (let i = 0; i < col; i++) {\n                if (mt[row][i] < 0) {\n                    cnt++;\n                }\n            }\n            return col - cnt;\n        }\n\n        /**\n         * Detect relative cell followed by direction (for merge cell)\n         */\n        function detectMergeCell(row, col, direction, mt) {\n            let result = [];\n\n            if (direction == 'left') {\n                if (col > 0) {\n                    let colIdx = col - 1;\n                    let rowIdx = row;\n                    while (colIdx >= 0 && mt[rowIdx][colIdx] == -2) {\n                        colIdx--;\n                    }\n                    while (rowIdx >= 0 && mt[rowIdx][colIdx] == -1) {\n                        rowIdx--;\n                    }\n                    result.push(rowIdx);\n                    result.push(colIdx);\n                }\n            } else if (direction == 'right') {\n                if (col + 1 < mt[0].length) {\n                    let colIdx = col + 1;\n                    let rowIdx = row;\n                    while (rowIdx >= 0 && mt[rowIdx][colIdx] == -1) {\n                        rowIdx--;\n                    }\n                    result.push(rowIdx);\n                    result.push(colIdx);\n                }\n            } else if (direction == 'up') {\n                if (row > 0) {\n                    let colIdx = col;\n                    let rowIdx = row - 1;\n                    while (colIdx >= 0 && mt[rowIdx][colIdx] == -2) {\n                        colIdx--;\n                    }\n                    while (rowIdx >= 0 && mt[rowIdx][colIdx] == -1) {\n                        rowIdx--;\n                    }\n                    result.push(rowIdx);\n                    result.push(colIdx);\n                }\n            } else if (direction == 'down') {\n                if (row + 1 < mt.length) {\n                    let colIdx = col;\n                    let rowIdx = row + 1;\n                    while (colIdx >= 0 && mt[rowIdx][colIdx] == -2) {\n                        colIdx--;\n                    }\n                    result.push(rowIdx);\n                    result.push(colIdx);\n                }\n            }\n            if (result.length > 0 && result[1] >= 0) {\n                result[1] = a2rPosition(result[0], result[1], mt);\n            } else {\n                result = [];\n            }\n            return result;\n        }\n\n        /**\n         * Utility method for add position to result array\n         * Eliminate duplicated result\n         */\n        function add(arr, value) {\n            if (!value || value.length == 0 || value[0] < 0 || value[1] < 0) {\n                return;\n            }\n            let existed = false;\n            let length = arr.length;\n            for (let i = 0; i < length; i++) {\n                v = arr[i];\n                if (v[0] == value[0] && v[1] == value[1]) {\n                    existed = true;\n                    return false;\n                }\n            }\n            if (!existed) {\n                arr.push(value);\n            }\n        }\n\n        /**\n         * Find previous cell on row\n         */\n        function prevCell(row, col, mt) {\n            let result = [];\n            result.push(row);\n\n            if (col >= 0) {\n                let colIdx = col;\n                while (colIdx >= 0 && mt[row][colIdx] < 0) {\n                    colIdx--;\n                }\n                result.push(colIdx >= 0 ? a2rPosition(row, colIdx, mt) : colIdx);\n            } else {\n                result.push(-1);\n            }\n            return result;\n        }\n\n        return {\n            // Reset internal state\n            reset: function() {\n                this.mt = [];\n                this.debug = false;\n            },\n\n            /**\n             * Load table structure, convert to matrix\n             */\n            load: function(table, escapeCls, debug) {\n                if (typeof Array.fill == 'undefined') {\n                    Array.prototype.fill = function(value) {\n                        let length = this.length;\n                        for (let i = 0; i < length; i++) {\n                            this[i] = value;\n                        }\n                        return this;\n                    }\n                }\n                let tableEle = typeof (table) === 'object' ? table : document.querySelector(table);\n                let ts = [];\n                let escapeClsArr = escapeCls ? escapeCls.split(',') : [];\n                tableEle.querySelectorAll('tr').forEach(trEle => {\n                    let rowArr = [];\n                    trEle.querySelectorAll('th,td').forEach(tdEle => {\n                        if (escapeClsArr.length > 0) {\n                            for (let i = 0, len = escapeClsArr.length; i < len; i++) {\n                                if (tdEle.classList.contains(escapeClsArr[i])) {\n                                    return;\n                                }\n                            }\n                        }\n                        let cellArr = [];\n                        cellArr.push(~~tdEle.getAttribute('rowspan') || 1);\n                        cellArr.push(~~tdEle.getAttribute('colspan') || 1);\n                        rowArr.push(cellArr);\n                    });\n                    ts.push(rowArr);\n                });\n\n                let mt = [];\n                let rowCnt = ts.length;\n                let colCnt = 0;\n\n                //Get column counter in first row\n                for (let i = 0, len = ts.length > 0 ? ts[0].length : 0; i < len; i++) {\n                    colCnt += ts[0][i][1];\n                }\n\n                //Fill matrix with same value for each cell in row\n                for (let i = 0; i < rowCnt; i++) {\n                    let rowArr = new Array(colCnt).fill(i + 1);\n                    mt.push(rowArr);\n                }\n                //Figure out HTML table structure with 2D matrix\n                for (let i = 0; i < rowCnt; i++) {\n                    let rowArr = ts[i];\n                    let tIndex = 0;\n                    let len = rowArr.length;\n                    for (let j = 0; j < len; j++) {\n                        let colArr = rowArr[j];\n                        //Skip merged cell\n                        while (mt[i][tIndex] < 0) {\n                            tIndex++;\n                        }\n                        let rowSpan = colArr[0];\n                        let colSpan = colArr[1];\n                        //-2 indicate for colspan\n                        for (let k = 1; k < colSpan; k++) {\n                            mt[i][tIndex + k] = -2;\n                        }\n                        for (let k = 1; k < rowSpan; k++) {\n                            //-1 indicate for rowspan\n                            mt[i + k][tIndex] = -1;\n                            for (let l = 1; l < colSpan; l++) {\n                                //-2 indicate for colspan\n                                mt[i + k][tIndex + l] = -2;\n                            }\n                        }\n                        tIndex += colSpan;\n                    }\n                }\n\n                this.mt = mt;\n                this.debug = debug;\n            },\n\n            /**\n             * Get relation cell\n             * @param direction top, right, bottom, left\n             */\n            getRelCell: function(row, col, direction) {\n                let arr = [];\n                let acol = r2aPosition(row, col, this.mt);\n                let rowSpan = 1;\n                let colSpan = 1;\n                let mt = this.mt;\n\n                while (acol + colSpan < mt[row].length && mt[row][acol + colSpan] == -2) {\n                    colSpan++;\n                }\n                while (row + rowSpan < mt.length && mt[row + rowSpan][acol] == -1) {\n                    rowSpan++;\n                }\n                for (let i = 0; i < rowSpan; i++) {\n                    for (let j = 0; j < colSpan; j++) {\n                        if (j == 0 && direction == 'left') {\n                            let ret = detectMergeCell(row + i, acol, 'left', mt);\n                            add(arr, ret);\n                        }\n                        if (j == colSpan - 1 && direction == 'right') {\n                            let ret = detectMergeCell(row + i, acol + j, 'right', mt);\n                            add(arr, ret);\n                        }\n                        if (i == 0 && direction == 'up') {\n                            let ret = detectMergeCell(row, acol + j, 'up', mt);\n                            add(arr, ret);\n                        }\n                        if (i == rowSpan - 1 && direction == 'down') {\n                            let ret = detectMergeCell(row + i, acol + j, 'down', mt);\n                            add(arr, ret);\n                        }\n                    }\n                }\n\n                return arr;\n            },\n\n            /**\n             * Get multiple relation cell\n             * @param direction top, right, bottom, left\n             */\n            getMultiRelCell: function(lst, direction) {\n                let arr = [];\n                if (lst) {\n                    for (let i = 0, len = lst.length; i < len; i++) {\n                        let c = lst[i];\n                        let ret = this.getRelCell(c[0], c[1], direction);\n                        if (ret.length > 0) {\n                            for (let j = 0, retLen = ret.length; j < retLen; j++) {\n                                add(arr, ret[j]);\n                            }\n                        }\n                    }\n                }\n                return arr;\n            },\n\n            /**\n             * Get html structure (for render)\n             */\n            getHtmlStructure: function() {\n                let ts = [];\n                let mt = this.mt;\n                rowCnt = mt.length;\n\n                for (let i = 0; i < rowCnt; i++) {\n                    let t = [];\n                    colCnt = mt[i].length;\n\n                    for (let j = 0; j < colCnt;) {\n                        if (mt[i][j] >= 0) {\n                            let colSpan = 1;\n                            let rowSpan = 1;\n\n                            while (j + colSpan < colCnt && mt[i][j + colSpan] == -2) {\n                                colSpan++;\n                            }\n                            while (i + rowSpan < rowCnt && mt[i + rowSpan][j] == -1) {\n                                rowSpan++;\n                            }\n\n                            let c = [];\n                            c.push(rowSpan);\n                            c.push(colSpan);\n                            t.push(c);\n\n                            j += colSpan;\n                        } else {\n                            j++;\n                        }\n                    }\n                    if (t.length > 0) {\n                        ts.push(t);\n                    }\n                }\n                if (this.debug) {\n                    //Debug only\n                    for (let i = 0; i < mt.length; i++) {\n                        let arr = [];\n                        for (let j = 0; j < mt[i].length; j++) {\n                            arr.push(mt[i][j] >= 0 ? (' ' + mt[i][j]) : mt[i][j]);\n                        }\n                        console.log(arr.join(','));\n                    }\n                }\n\n                return ts;\n            },\n\n            /**\n             * Get cell in deleting column\n             */\n            deleteColAt: function(row, col, last) {\n                let acol = r2aPosition(row, col, this.mt);\n                let mt = this.mt;\n                let length = mt.length;\n                let result = [];\n\n                if (last == true) {\n                    while (acol + 1 < mt[row].length && mt[row][acol + 1] == -2) {\n                        acol++;\n                    }\n                }\n                for (let i = 0; i < length; i++) {\n                    if (mt[i][acol] < 0) {\n                        let rowIdx = i;\n                        let colIdx = acol;\n                        while (colIdx >= 0 && mt[rowIdx][colIdx] == -2) {\n                            colIdx--;\n                        }\n                        while (rowIdx >= 0 && mt[rowIdx][colIdx] == -1) {\n                            rowIdx--;\n                        }\n                        let changed = [];\n                        changed.push(rowIdx);\n                        changed.push(colIdx >= 0 ? a2rPosition(rowIdx, colIdx, this.mt) : colIdx);\n                        add(result, changed);\n                    } else {\n                        let changed = [];\n                        changed.push(i);\n                        changed.push(a2rPosition(i, acol, this.mt));\n                        add(result, changed);\n                    }\n                }\n\n                return result;\n            },\n\n            /**\n             * Get cell in deleting target row\n             */\n            deleteRowAt: function(row) {\n                let mt = this.mt;\n                let length = mt.length;\n                let result = [];\n\n                if (row >= 0 && row < mt.length) {\n                    for (let j = 0; j < mt[row].length; j++) {\n                        if (mt[row][j] < 0) {\n                            let rowIdx = row;\n                            let colIdx = j;\n                            while (colIdx >= 0 && mt[rowIdx][colIdx] == -2) {\n                                colIdx--;\n                            }\n                            while (rowIdx >= 0 && mt[rowIdx][colIdx] == -1) {\n                                rowIdx--;\n                            }\n                            let changed = [];\n                            changed.push(rowIdx);\n                            changed.push(colIdx >= 0 ? a2rPosition(rowIdx, colIdx, this.mt) : colIdx);\n                            add(result, changed);\n                        } else {\n                            let changed = [];\n                            changed.push(row);\n                            changed.push(a2rPosition(row, j, this.mt));\n                            add(result, changed);\n                        }\n                    }\n\n                }\n                return result;\n            },\n\n            /**\n             * Get insertable cell on next row\n             */\n            insertableCellNextRow: function(row, col) {\n                let acol = r2aPosition(row, col, this.mt);\n                let result = [];\n                if (acol >= 0 && row < this.mt.length - 1) {\n                    result = prevCell(row + 1, acol, this.mt);\n                }\n                return result;\n            },\n\n            /**\n             * Get insertable cell on row\n             */\n            insertableCell: function(row, col) {\n                let acol = r2aPosition(row, col, this.mt);\n                return prevCell(row, acol, this.mt);\n            },\n\n            /**\n             * Get previous cell (also support cell with rowspan)\n             */\n            beforeCell: function(row, col, pRowSpan) {\n                let acol = r2aPosition(row, col, this.mt);\n                let mt = this.mt;\n                let result = [];\n                for (let i = 0; i < pRowSpan; i++) {\n                    let colIdx = acol - 1;\n                    let rowIdx = row + i;\n                    while (colIdx >= 0 && mt[rowIdx][colIdx] < 0) {\n                        colIdx--;\n                    }\n                    let c = [];\n                    c.push(rowIdx);\n                    c.push(colIdx >= 0 ? a2rPosition(rowIdx, colIdx, this.mt) : colIdx);\n                    result.push(c);\n                }\n                return result;\n            },\n\n            /**\n             * Transform column to absolute position\n             */\n            absoluteCol: function(row, col) {\n                return r2aPosition(row, col, this.mt);\n            },\n\n            /**\n             * Get row size\n             */\n            getRowSize: function(row) {\n                let result = 0;\n                if (row >= 0 && row < this.mt.length) {\n                    result = this.mt[row].length;\n                }\n                return result;\n            },\n\n            /**\n             * Check cell is exists\n             */\n            hasCell: function(row, col) {\n                let acol = r2aPosition(row, col, this.mt);\n                let result = false;\n                if (row >= 0 && row < this.mt.length && acol >= 0 && acol < this.mt[row].length) {\n                    result = this.mt[row][acol] > 0;\n                }\n                return result;\n            },\n\n            /**\n             * Get table figured out matrix\n             */\n            getMatrix: function() {\n                return this.mt;\n            },\n\n            /**\n             * Extends cell by nRow and nCol more\n             * In case of cell can extend, return all available cell in range, exclude current cell\n             * Otherwise, throw error\n             */\n            extendSize: function(row, col, nRow, nCol) {\n                let acol = r2aPosition(row, col, this.mt);\n                let mt = this.mt;\n                let result = {};\n                let errorCode = 0;\n                let mergeCells = [];\n                let splitCells = [];\n\n                //Detect size of current cell\n                let cellRowSize = 1;\n                let cellColSize = 1;\n                for (let j = acol + 1; j < mt[row].length && mt[row][j] == -2; j++) {\n                    cellColSize++;\n                }\n                for (let i = row + 1; i < mt.length && mt[i][acol] == -1; i++) {\n                    cellRowSize++;\n                }\n\n                //Merge cell\n                if (nRow > cellRowSize || nCol > cellColSize) {\n                    //Top left\n                    let topLeft = {\n                        row: row,\n                        col: acol\n                    };\n\n                    //Top right\n                    let cnt = 1;\n                    let topRight;\n                    if (nCol > cellColSize) {\n                        for (let j = acol + 1; j < mt[row].length; j++) {\n                            if (mt[row][j] == -1) {\n                                break;\n                            }\n                            cnt++;\n                            if (cnt == nCol) {\n                                topRight = {\n                                    row: row,\n                                    col: j\n                                };\n                                break;\n                            }\n                        }\n                        if (cnt != nCol && errorCode == 0) {\n                            errorCode = -1;\n                        }\n                    } else {\n                        topRight = {\n                            row: row,\n                            col: acol + nCol - 1\n                        };\n                    }\n\n                    //Bottom left\n                    cnt = 1;\n                    let bottomLeft;\n                    if (nRow > cellRowSize) {\n                        for (let i = row + 1; i < mt.length; i++) {\n                            if (mt[i][acol] == -2) {\n                                break;\n                            }\n                            cnt++;\n                            if (cnt == nRow) {\n                                bottomLeft = {\n                                    row: i,\n                                    col: acol\n                                };\n                                break;\n                            }\n                        }\n                        if (cnt != nRow && errorCode == 0) {\n                            errorCode = -2;\n                        }\n                    } else {\n                        bottomLeft = {\n                            row: row + nRow - 1,\n                            col: acol\n                        };\n                    }\n\n\n                    let maxCellBound = {\n                        row: row + cellRowSize - 1,\n                        col: acol + cellColSize - 1\n                    };\n\n                    //Check from bottom-left (row)\n                    if (bottomLeft.row + 1 < mt.length) {\n                        let nextRow = bottomLeft.row + 1;\n                        for (let i = bottomLeft.col; i <= topRight.col; i++) {\n                            //Check but excluding cells existed in current cell range\n                            if ((nextRow > maxCellBound.row || i > maxCellBound.col) && mt[nextRow][i] == -1) {\n                                errorCode = -1;\n                                break;\n                            }\n                        }\n                    }\n                    //Check from top-right (column)\n                    let nextCol = topRight.col + 1;\n                    for (let i = topRight.row; i <= bottomLeft.row; i++) {\n                        //Check but excluding cells existed in current cell range\n                        if ((i > maxCellBound.row || nextCol > maxCellBound.col) && nextCol < mt[i].length && mt[i][nextCol] == -2) {\n                            errorCode = -2;\n                            break;\n                        }\n                    }\n\n                    let bottomRight = {\n                        row: bottomLeft.row,\n                        col: topRight.col\n                    };\n\n                    //Get all cell in extending range\n                    for (let i = topLeft.row; i <= bottomLeft.row; i++) {\n                        for (let j = topLeft.col; j <= topRight.col; j++) {\n                            if (mt[i][j] > 0) {\n                                let c = [];\n                                c.push(i);\n                                c.push(a2rPosition(i, j, this.mt));\n                                add(mergeCells, c);\n                            }\n                        }\n                    }\n                }\n                //Split cell\n                if (nRow < cellRowSize || nCol < cellColSize) {\n                    for (let cntR = 0; cntR < cellRowSize; cntR++) {\n                        let cnt = 0;\n                        let startCell;\n\n                        //Fill up cell with negative value in matrix after resized with positive value (insert cell)\n                        if (cntR < nRow) {\n                            //For missing cells only\n                            cnt = cellColSize - nCol;\n\n                            if (cnt > 0) {\n                                startCell = prevCell(row + cntR, acol, mt);\n                            }\n                        } else {\n                            //For missing row\n                            cnt = cellColSize;\n                            startCell = prevCell(row + cntR, acol, mt);\n                        }\n                        if (cnt > 0) {\n                            splitCells.push({\n                                row: row + cntR,\n                                start: startCell,\n                                howMany: cnt\n                            });\n                        }\n                    }\n                }\n\n\n                result.errorCode = errorCode;\n                result.mergeCells = mergeCells;\n                result.splitCells = splitCells;\n\n                return result;\n            }\n        }\n    }());\n\n    window.Table2Matrix = my;\n}());\n"],
  "mappings": "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",
  "names": ["my", "mt", "debug", "r2aPosition", "row", "col", "result", "cnt", "colCnt", "i", "__name", "a2rPosition", "detectMergeCell", "direction", "colIdx", "rowIdx", "add", "arr", "value", "existed", "length", "prevCell", "table", "escapeCls", "tableEle", "ts", "escapeClsArr", "trEle", "rowArr", "tdEle", "len", "cellArr", "rowCnt", "tIndex", "j", "colArr", "rowSpan", "colSpan", "k", "l", "acol", "ret", "lst", "c", "retLen", "t", "last", "changed", "pRowSpan", "nRow", "nCol", "errorCode", "mergeCells", "splitCells", "cellRowSize", "cellColSize", "topLeft", "topRight", "bottomLeft", "maxCellBound", "nextRow", "nextCol", "bottomRight", "cntR", "startCell"]
}
